;(load "stdlib.scm")
(assert 2 (+ 1 1))
(assert 3 (- (+ 4 6 3) 3 5 2))

(assert #t (number? 124))
(assert #t (string? "hello"))
(assert #t (symbol? 'hello))
(assert #t (list? '(1 2 3)))

;(assert "flying-fish" (symbol->string 'flying-fish))
;(assert  (string->symbol ""))
(assert 'flying-fish (string->symbol "flying-fish"))
(assert "yes" (if (> 2 3) "no" "yes"))
(assert 9 (if (= 3 3) (+ 2 3 (- 5 1)) "unequal"))

(assert 'greater (cond ((> 3 2) 'greater) ((< 3 2) 'less)))
(assert 'equal (cond ((> 3 3) 'greater) ((< 3 3) 'less) (else 'equal)))
(assert 'composite (case (* 2 3) ((2 3 5 7) 'prime) ((1 4 6 8 9) 'composite)))
(assert 'consonant (case (car '(c d)) ((a e i o u) 'vowel) ((w y) 'semivowel) (else 'consonant)))
(assert 'semivowel (case (car '(w d)) ((a e i o u) 'vowel) ((w y) 'semivowel) (else 'consonant)))

(assert #t (string? "Hello"))
(assert "  " (make-string 2))
(assert "aa" (make-string 2 #\a))
(assert "Apple" (string #\A #\p #\p #\l #\e))
(assert 5 (string-length "Apple"))
;(assert "l" (string-ref "Apple" 3))
(assert "pp" (substring "Apple" 1 3))
(assert "AppleBanana" (string-append "Apple" "Banana"))
(assert '(#\A #\b #\c) (string->list "Abc"))
(assert "Cmsk" (list->string '(#\C #\m #\s #\k)))

(assert #t (eq? 'a 'a))
(assert #f (eq? 'a 'b))
(assert #t (eq? '() '()))
(assert #t (eq? '(1 2 3) '(1 2 3)))

(assert #f (equal? '(1 2 3) '(1 2 3 4)))
(assert #f (equal? 'b 'a))
(assert #t (equal? 'a 'a))
(assert #t (equal? '() '()))
(assert #t (equal? '(1 2) '(1 2)))
(assert #t (equal? 2 #\2))
(assert #t (equal? '(1 #\2) '(1 2)))

(assert '(1 . 2) (cons 1 2))
(assert '(1 2 3) (cons 1 '(2 3)))
(assert 1 (car '(1 2)))
(assert '(2 3) (cdr '(1 2 3)))
(assert '() (cdr '(1)))
(assert '(2) (cdr '(1 . 2)))
(assert '(2 . 3) (cdr '(1 2 . 3)))

(define x 3)
(define y 5)
(define str "a string")
(assert 5 (+ x 2))
(assert 6 (+ x (- y 2)))
(assert "a string" str)

(define (f x y) (+ x y))
(assert 3 (f 1 2))
(define (factorial x) (if (= x 1) 1 (* x (factorial (- x 1)))))
(assert 3628800 (factorial 10))

(define (counter inc) (lambda (x) (set! inc (+ x inc)) inc))
(define my-count (counter 5))
(assert 8 (my-count 3))
(assert 14 (my-count 6))

(assert '(3 4 5 6) (map (curry + 2) '(1 2 3 4)))
(assert '(1 2) (filter even? '(1 2 3 4)))
;; These should return errors?
;(assert (1 . 2) (cons 1 2))
;(assert (1 2 3) (cons 1 '(2 3)))
;(assert 1 (car '(1 2)))
;(assert (2 3) (cdr '(1 2 3)))
;(assert () (cdr '(1)))
;(assert (2) (cdr '(1 . 2)))
;(assert (2 . 3) (cdr '(1 2 . 3)))
